%!TEX program = xelatex
\documentclass[10pt, compress, handout]{beamer}
\usepackage[titleprogressbar]{../../cls/beamerthemem}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{minted}

\usepgfplotslibrary{dateplot}

\usemintedstyle{trac}

\setbeamertemplate{caption}[numbered]
\setbeamertemplate{theorems}[numbered]
\newtheorem{crl}{Corollary}[theorem]
\newtheorem*{solution*}{Solution}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{version}
%\excludeversion{proof}
%\excludeversion{solution*}

\usepackage{mathtools}
\usepackage{multicol}
\usepackage{qtree}

\usepackage{tikz}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
	\ifmmode%
	\old@comma\discretionary{}{}{}%
	\else%
	\old@comma%
	\fi%
}
\makeatother

\title{CSCI 3190 Tutorial of Week 11}
\subtitle{Trees}
\author{LI Haocheng}
\institute{Department of Computer Science and Engineering}

\begin{document}

\maketitle

\begin{frame}[fragile]
\frametitle{Recursive Algorithms}
\begin{columns}
	\begin{column}{.4\linewidth}
		\begin{example}
			\setcounter{algorithm}{0}
			\begin{algorithm}[H]
				\caption{Recursive Algorithm to Find $a^{2^n}$}
				\label{alg:a2n}
				\begin{algorithmic}[1]
					\Require $a \in \mathbb{R}, n \in \mathbb{N}$.
					\Ensure $a^{2^n}$.
					\Procedure{pow2}{$a$, $n$}
					\onslide<2->\If {$n = 0$}
					\State\Return $a$
					\EndIf
					\State $p \gets$ \Call{pow2}{$a$, $n - 1$}
					\State\Return $p \times p$
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
		\end{example}
	\end{column}
	\begin{column}{.6\linewidth}
		\onslide<1->\begin{example}
			\setcounter{algorithm}{1}
			\begin{algorithm}[H]
				\caption{Recursive Algorithm to Find $a^{n}$}
				\label{alg:an}
				\begin{algorithmic}[1]
					\Require $a \in \mathbb{R}, n \in \mathbb{N}$.
					\Ensure $a^{n}$.
					\Procedure{pow}{$a$, $n$}
					\onslide<3>\If {$n = 0$}
					\Return $1$
					\EndIf
					\State $p \gets$ \Call{pow}{$a$, $\lfloor\frac{n}{2}\rfloor$}
					\If {$n \equiv 0 \pmod{2}$}
					\Return $p \times p$
					\EndIf
					\State\Return $p \times p \times a$
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
		\end{example}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Double Tower of Hanoi}
\begin{example}
	A Double Tower of Hanoi contains $2n$ disks of $n$ different sizes, two of each size. As usual, we can move
	only one disk at a time, without putting a larger one over a smaller one. Assume that disks of equal size are
	indistinguishable from each other:\begin{enumerate}[(a)]
		\item Write a pseudo-code to solve the above problem recursively.
		\item Set up a recurrence equation to count the number of steps to move $2n$ disks. 
		\item Solve the recurrence equation and give the complexity of your algorithm.
	\end{enumerate}
\end{example}
\begin{solution*}
	\begin{columns}
		\begin{column}{.5\linewidth}
			\begin{enumerate}[(a)]
				\item See Algorithm \ref{a-3}.		
				\item $H_{2n} = 2H_{2n - 2} + 2$.
				\item \begin{align}
				H_{2n} & = 2(2H_{2n - 4} + 2) + 2\\
				& = 4H_{2n - 4} + 4 + 2\\
				& \cdots\\
				& = 2^{n + 1} - 2.\\
				& = O(2^n).
				\end{align}
			\end{enumerate}
		\end{column}
		\begin{column}{.5\linewidth}
			\begin{algorithm}[H]
				\caption{Double Tower of Hanoi}
				\label{a-3}
				\begin{algorithmic}
					\Procedure{Hanoi}{$h$, $b$, $e$, $m$}
					\If{$h$ = 0}
					\State \Return
					\ElsIf{$h$ = 2}
					\State \Call{Move}{$b$, $e$}
					\State \Call{Move}{$b$, $e$}
					\Else
					\State \Call{Hanoi}{$h - 2$, $b$, $m$, $e$}
					\State \Call{Hanoi}{2, $b$, $e$}
					\State \Call{Hanoi}{$h - 2$, $m$, $e$, $b$}
					\EndIf
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
		\end{column}
	\end{columns}
\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Cycle}
\onslide<1->\begin{example}
	Let $P_1$ and $P_2$ be two paths without cycle between the vertices $u$ and $v$
	in the simple graph $G$ that do not contain the same set of edges.
	Show that there is a cycle in $G$.
\end{example}
\onslide<2>\textbf{Proof.}	Let
the paths $P_1$ and $P_2$ be $u = x_0, x_1, \cdots, x_n = v$ and $u = y_0, y_1$, $\cdots$, $y_m = v$, respectively. Since the paths do not contain cycles, they must diverge eventually. We can suppose that $x_0 = y_0, x_1 = y_1$, $\cdots$, $x_i = y_i$, but $x_{i + 1} \ne y_{i + 1}$. To form our cycle, we follow the path $y_i, y_{i + 1}, y_{i + 2}$, and so on,
until it once again first encounters a vertex on $P_1$. Once we are back on $P_1$, we
follow it along-forwards or backwards, as necessary-to return
to $x_i$. Since $x_i = y_i$, this certainly forms a cycle.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Tree}
	\begin{theorem}
		An undirected graph is a tree if and only if there is a unique path without cycle between any two of its vertices.
	\end{theorem}
	\onslide<2>\begin{proof}
		First assume that $T$ is a tree which is connected graph without cycle.
		Because $T$ is connected, there is a path without cycle between two vertices $x$ and $y$.
		Moreover, this path must be unique, for if there were a second such path,
		they would form a cycle.	
		This implies that there is a cycle in $T$.
	
		Now assume that there is a unique path without cycle between any two vertices of a graph $T$.
		Then $T$ is connected, because there is a path between any two of its vertices.
		Furthermore, $T$ can have no cycles.
		To see that this is true, suppose $T$ had a cycle that contained the vertices $x$ and $y$.
		Then there would be two simple paths between $x$ and $y$.
	\end{proof}
\end{frame}

\plain{Questions?}

\end{document}
