%!TEX program = xelatex
\documentclass[10pt, compress]{beamer}
\usepackage[titleprogressbar]{../../cls/beamerthemem}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{minted}

\usepgfplotslibrary{dateplot}

\usemintedstyle{trac}

\setbeamertemplate{caption}[numbered]
\setbeamertemplate{theorems}[numbered]
\newtheorem{crl}{Corollary}[theorem]
\newtheorem*{solution*}{Solution}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{version}
%\excludeversion{proof}
%\excludeversion{solution*}

\usepackage{mathtools}
\usepackage{multicol}
\usepackage{qtree}

\usepackage{tikz}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
	\ifmmode%
	\old@comma\discretionary{}{}{}%
	\else%
	\old@comma%
	\fi%
}
\makeatother

\title{CSCI 3190 Tutorial of Week 12}
\subtitle{Trees}
\author{LI Haocheng}
\institute{Department of Computer Science and Engineering}

\begin{document}

\maketitle

\begin{frame}[allowframebreaks]
	\frametitle{Longest Common Subsequence}
	\begin{example}
		Consider the longest common subsequence problem between sequence $A[1\cdots m]$ and sequence $B[1\cdots n]$. Give a
		recursive algorithm to print out ALL the longest common subsequences assuming that you already build the
		table $T[1\cdots m, 1\cdots n]$ where the entry $T[j, k]$ represents the length of the longest common subsequence between $A[1\cdots j]$ and $B[1\cdots k]$.
	\end{example}
	\begin{solution*}
		See Algorithm \ref{a-5}.
		\begin{algorithm}[H]
			\caption{Print Out ALL the LCSes}
			\label{a-5}
			\begin{algorithmic}
				\Procedure{All}{$T$, $A$, $B$, $j$, $k$}
				\If{$j \cdot k = 0$} \Return $\{``"\}$
				\ElsIf{$A[j] = B[k]$} \Return $\{C + A[j] \colon Z \in \Call{All}{T, A, B, j - 1, k - 1}\}$
				\Else
				\State $R \coloneqq \{\}$
				\If{$T[j, k - 1] \ge T[j - 1, k]$} $R \coloneqq R \cup \Call{All}{T, A, B, j, k - 1}$
				\EndIf
				\If{$T[j - 1, k] \ge T[j, k - 1]$} $R \coloneqq R \cup \Call{All}{T, A, B, j - 1, k}$
				\EndIf
				\State \Return $R$
				\EndIf
				\EndProcedure
			\end{algorithmic}
		\end{algorithm}
	\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Terminology}
\begin{columns}
	\begin{column}{.6\linewidth}
		\onslide<1->\begin{example}
			In the rooted tree $T$ (with root $a$) shown in Figure \ref{f-11-1-5}, find the parent of $c$, the children of $g$, the
			siblings of $h$, all ancestors of $e$, all descendants of $b$, all internal vertices, and all leaves. What
			is the subtree rooted at $g$?
		\end{example}
		\onslide<2>\textbf{Solution} The parent of $c$ is $b$. The children of $g$ are $h$, $i$, and $j$. The siblings of $h$ are $i$ and $j$. The ancestors of $e$ are $c$, $b$, and $a$. The descendants of $b$ are $c$, $d$, and $e$. The internal vertices are $a$, $b$, $c$, $g$, $h$, and $j$. The leaves are $d$, $e$, $f$, $i$, $k$, $l$, and $m$.
	\end{column}
	\onslide<1->\begin{column}{.4\linewidth}
		\begin{figure}
			\centering
			$\Tree [.a [.b [.c d e ] ] f [.g [.h k ] i [.j l m ]]]$
			\caption{A Rooted Tree $T$}
			\label{f-11-1-5}
		\end{figure}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Left Child}
\begin{columns}
	\begin{column}{.6\linewidth}
		\onslide<1->\begin{example}
			What are the left and right children of $d$ in the binary tree $T$ shown in Figure \ref{f-11-1-8} (where the order is that implied by the drawing)? What are the left and right subtrees of $c$?
		\end{example}
		\onslide<2>\textbf{Solution} The left child of $d$ is $f$ and the right child is $g$.
	\end{column}
	\onslide<1->\begin{column}{.4\linewidth}
		\begin{figure}
			\centering
			$\Tree [.a [.b [.d f g ] e ] [.c [.h j ] [.i k [.l m ]]]]$
			\caption{A Binary Tree $T$}
			\label{f-11-1-8}
		\end{figure}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{$m$-ary Tree}
	\onslide<1->\begin{theorem}\label{t-11-1-3}
		A full $m$-ary tree with $i$ internal vertices contains $n = m i + 1$ vertices.
	\end{theorem}
	\onslide<2>\begin{proof}
		Every vertex, except the root, is the child of an internal vertex. Because each of the $i$ internal vertices has $m$ children, there are $m i$ vertices in the tree other than the root. Therefore, the tree contains $n = m i + 1$ vertices
	\end{proof}
\end{frame}

\begin{frame}[fragile]
\frametitle{Preorder}
\begin{columns}
	\begin{column}{.6\linewidth}
		\onslide<1->\begin{example}
			Determine the orders in which a preorder, a inorder and a postorder traversal visits the vertices of the given ordered rooted tree in Figure \ref{f-11-3-e7}.
		\end{example}
		\begin{solution*}
			\begin{enumerate}
				\item<2-> $a, b, d, e, f, g, c$.
				\item<3-> $d, b, f, e, g, a, c$.
				\item<4-> $d, f, g, e, b, c, a$.
			\end{enumerate}
		\end{solution*}
	\end{column}
	\onslide<1->\begin{column}{.4\linewidth}
		\begin{figure}
			\centering
			$\Tree [.a [.b d [.e f g ]] c ]$
			\caption{A Rooted Tree $T$}
			\label{f-11-3-e7}
		\end{figure}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Expression}
\begin{columns}
	\begin{column}{.6\linewidth}
		\onslide<1->\begin{example}
			\begin{enumerate}
				\item Represent the expression $((x + 2) \uparrow 3) \cdot (y - (3 + x)) - 5$ using a binary tree.
				\item Write this expression in prefix notation.
				\item Write this expression in postfix notation.
				\item Write this expression in infix notation.
			\end{enumerate}
		\end{example}
		\begin{solution*}
			\begin{enumerate}
				\item<2-> $-\ \cdot\ \uparrow\ +\ x\ 2\ 3\ -\ y\ +\ 3\ x\ 5$
				\item<3-> $x\ 2\ +\ 3\ \uparrow\ y\ 3\ x\ +\ -\ \cdot\ 5\ -$
				\item<4-> $x\ +\ 2\ \uparrow\ 3\ \cdot\ y\ -\ 3\ +\ x\ -\ 5$
			\end{enumerate}
		\end{solution*}
	\end{column}
	\onslide<2>\begin{column}{.4\linewidth}
		\begin{solution*}
			\begin{figure}
				\centering
				$\Tree [.- [.\(\cdot\) [.\(\uparrow\) [.+ x 2 ] 3 ] [.- y [.+ 3 x ] ] ] 5 ]$
				\caption{A Rooted Tree $T$}
				\label{f-11-3-e16}
			\end{figure}
		\end{solution*}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Construction}
	\begin{columns}
		\begin{column}{.6\linewidth}
			\onslide<1->\begin{example}
				Construct the ordered rooted tree whose preorder traversal is $a, b, f, c, g, h, i, d, e, j, k, l$, where $a$ has four children, $c$ has three children, $j$ has two children, $b$ and $e$ have one child each, and all other vertices are leaves.
			\end{example}
		\end{column}
		\onslide<2>\begin{column}{.4\linewidth}
			\begin{solution*}
				\begin{figure}
					\centering
					$\Tree [.a [.b f ] [.c g h i ] d [.e [.j k l ] ] ]$
					\caption{A Rooted Tree $T$}
					\label{f-11-3-e25}
				\end{figure}
			\end{solution*}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Counting}
\begin{example}
	\begin{enumerate}[(a)]
		\item Write a recursive algorithm to count the number of leaves (nodes) in a binary tree pointed to by a tree node pointer called \texttt{root}. You can assume that each tree node \texttt{x} has a pointer \texttt{x.left} pointing to its left sub-tree and a pointer \texttt{x.right} pointing to its right sub-tree.
		\item Express the time complexity of your algorithm with a recurrence equation.
		\item solve the recurrence.
	\end{enumerate}
\end{example}
\begin{solution*}
	\begin{columns}
		\begin{column}{.4\linewidth}
			\begin{enumerate}[(a)]
				\item See Algorithm \ref{a-1}.
				\item $T(root) = T(root.left) + T(root.right) + 1$
				\item $T(root) = T(root.left.left) + T(root.left.right) + T(root.right.left) + T(root.right.right) + 3 = \cdots = n$
			\end{enumerate}
		\end{column}
		\begin{column}{.6\linewidth}
			\begin{algorithm}[H]
				\caption{Counting}
				\label{a-1}
				\begin{algorithmic}
					\Procedure{Count}{$root$}
					\If{$root.left = 0 \wedge root.right = 0$}
					\State \Return 1
					\EndIf
					\State $c \coloneqq 0$\Comment{1 if counting nodes.}
					\If{$root.left \ne 0$}
					\State $c \coloneqq c + \Call{Count}{root.left}$
					\EndIf
					\If{$root.right \ne 0$}
					\State $c \coloneqq c + \Call{Count}{root.right}$
					\EndIf
					\State \Return $c$
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
		\end{column}
	\end{columns}
\end{solution*}
\end{frame}

\plain{Questions?}

\end{document}
