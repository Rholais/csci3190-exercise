%!TEX program = xelatex
\documentclass[10pt, compress, handout]{beamer}
\usepackage[titleprogressbar]{../../cls/beamerthemem}

\setbeamertemplate{caption}[numbered]
\setbeamertemplate{theorems}[numbered]
\newcounter{example}
\resetcounteronoverlays{example}
\newtheorem{crl}{Corollary}[theorem]
\newtheorem{eg}[example]{Example}
\newtheorem*{solution*}{Solution}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{minted}

\usepackage{cleveref}
\crefname{example}{Example}{Examples}

\usepgfplotslibrary{dateplot}

\usemintedstyle{trac}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\resetcounteronoverlays{algorithm}

\usepackage{version}
\excludeversion{proof}
\excludeversion{solution*}

\usepackage{mathtools}
\usepackage{multicol}
\usepackage{qtree}

\usepackage{tikz}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
    \ifmmode%
    \old@comma\discretionary{}{}{}%
    \else%
    \old@comma%
    \fi%
}
\makeatother

\title{CSCI 3190 Tutorial of Week 10}
\subtitle{Mathematical Induction}
\author{LI Haocheng}
\institute{Department of Computer Science and Engineering}

\begin{document}

\maketitle

\begin{frame}
\frametitle{Right Trominoes}
\begin{columns}
    \begin{column}{.3\linewidth}
        \begin{eg}
            Let $n \in \mathbb{N}^+$. Show that every $2^n \times 2^n$ checkerboard with one square removed can be tiled using right trominoes, where these pieces cover three squares at a time.
        \end{eg}
        \begin{figure}
            \includegraphics[width=.4\linewidth]{tromino}
            \caption{Tromino}
        \end{figure}
    \end{column}
    \begin{column}{.8\linewidth}
        \begin{proof}
            \begin{description}
                \item[Base]<2-> $P(1)$ is true, obviously.
                \item[Induction]<3> Split the $2^{k + 1} \times 2^{k + 1}$ checkerboard with one square removed into four checkerboards of size $2^k \times 2^k$. Now temporarily remove the
                square from each of the three full checkerboards at the center of the original. By the inductive hypothesis,
                each of these four checkerboards with a square removed can be tiled by right trominoes. Furthermore, the three squares that were temporarily removed can be covered by one right
                tromino.
            \end{description}
        \end{proof}
    \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Recursion Algorithm}
\begin{eg}
    Give a recursive algorithm for tiling a $2^n \times 2^n$ checkerboard with one square missing using right trominoes.
\end{eg}
\onslide<2>\begin{solution*}
    If $n = 1$ (basis step), place the one right tromino so that its
    armpit corresponds to the hole in the $2 \times 2$ board. If $n > 1$, then
    divide the board into four boards, each of size $2^{n - 1} \times 2^{n-1}$,
    notice which quarter the hole occurs in, position one right triomino
    at the center of the board with its armpit in the quarter
    where the missing square is, and
    invoke the algorithm recursively four times -- once on each of
    the $2^{n - 1} \times 2^{n - 1}$ boards, each of which has one square missing.
\end{solution*}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Double Tower of Hanoi}
\begin{eg}
    A Double Tower of Hanoi contains $2n$ disks of $n$ different sizes, two of each size. As usual, we can move
    only one disk at a time, without putting a larger one over a smaller one. Assume that disks of equal size are
    indistinguishable from each other:\begin{enumerate}[(a)]
        \item Write a pseudo-code to solve the above problem recursively.
        \item Set up a recurrence equation to count the number of steps to move $2n$ disks. 
        \item Solve the recurrence equation and give the complexity of your algorithm.
    \end{enumerate}
\end{eg}
\begin{solution*}
    \begin{columns}
        \begin{column}{.5\linewidth}
            \begin{enumerate}[(a)]
                \item See Algorithm \ref{a-3}.        
                \item $H_{2n} = 2H_{2n - 2} + 2$.
                \item \begin{align}
                H_{2n} & = 2(2H_{2n - 4} + 2) + 2\\
                & = 4H_{2n - 4} + 4 + 2\\
                & \cdots\\
                & = 2^{n + 1} - 2.\\
                & = O(2^n).
                \end{align}
            \end{enumerate}
        \end{column}
        \begin{column}{.5\linewidth}
            \begin{algorithm}[H]
                \caption{Double Tower of Hanoi}
                \label{a-3}
                \begin{algorithmic}
                    \Procedure{Hanoi}{$h$, $b$, $e$, $m$}
                    \If{$h$ = 0}
                    \State \Return
                    \ElsIf{$h$ = 2}
                    \State \Call{Move}{$b$, $e$}
                    \State \Call{Move}{$b$, $e$}
                    \Else
                    \State \Call{Hanoi}{$h - 2$, $b$, $m$, $e$}
                    \State \Call{Hanoi}{2, $b$, $e$}
                    \State \Call{Hanoi}{$h - 2$, $m$, $e$, $b$}
                    \EndIf
                    \EndProcedure
                \end{algorithmic}
            \end{algorithm}
        \end{column}
    \end{columns}
\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge Lists}
\begin{eg}
    What is the least number of comparisons needed to merge any two lists in increasing order into one list in increasing order when the number of elements in the two lists are
    
    A) 1, 4? B) 2, 4? C) 3, 4? D) 4, 4?
\end{eg}
\onslide<2>\begin{solution*}
    A.
\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge Sort}
\begin{eg}
    Prove that the merge sort algorithm is correct.
\end{eg}
\onslide<2>\begin{proof}
    If
    $n = 1$, then the algorithm does nothing, which is correct because
    a list with one element is already sorted. Assume that
    the algorithm works correctly for $n = 1$ through $n = k$. If
    $n = k + 1$, then the list is split into two lists, $L_1$ and $L_2$. By the
    inductive hypothesis, \textit{mergesort} correctly sorts each of these
    sublists; furthermore, \textit{merge} correctly merges two sorted lists
    into one because with each comparison the smallest element
    in $L_1 \cup L_2$ not yet put into $L$ is put there.
\end{proof}
\end{frame}

\begin{frame}
\frametitle{Sorting Algorithm}
\begin{theorem} \label{t-11-2-1}
    A sorting algorithm based on binary comparisons requires at least $\lceil \log n! \rceil$ comparisons.
\end{theorem}
\onslide<2>\begin{proof}
    The complexity of a sort based on binary comparisons
    is measured in terms of the number of such comparisons used.
    The largest number of binary comparisons ever needed to sort a list with $n$ elements gives the worst-case performance of the algorithm. The most comparisons used equals the longest path length in the decision tree representing the sorting procedure. In other words, the largest number of comparisons ever needed is equal to the height of the decision tree.
    Because the height of a binary tree with $n!$ leaves is at least $\lceil \log n! \rceil$, at least $\lceil \log n! \rceil$ comparisons are needed.
\end{proof}
\end{frame}

\begin{frame}[fragile]
\frametitle{Cycle}
\begin{eg}
    Let $P_1$ and $P_2$ be two paths without cycle between the vertices $u$ and $v$
    in the simple graph $G$ that do not contain the same set of edges (i.e., the two paths are not the same).
    Show that there is a cycle in $G$.
\end{eg}
\onslide<2> \begin{proof}
    Let the paths $P_1$ and $P_2$ be $u = x_0, x_1, \cdots, x_n = v$ and $u = y_0, y_1$,
    $\cdots$, $y_m = v$, respectively. Since the paths do not contain cycles, they must diverge eventually. We can suppose that $x_0 = y_0, x_1 = y_1$, $\cdots$, $x_i = y_i$, but $x_{i + 1} \ne y_{i + 1}$. To form our cycle, we follow the path $y_i, y_{i + 1}, y_{i + 2}$, and so on,
    until it once again first encounters a vertex on $P_1$. Once we are back on $P_1$, we
    follow it along-forwards or backwards, as necessary-to return
    to $x_i$. Since $x_i = y_i$, this certainly forms a cycle.
\end{proof}
\end{frame}

\begin{frame}[fragile]
\frametitle{Tree}
\begin{theorem}
    An undirected graph is a tree if and only if there is a unique path without cycle between any two of its vertices.
\end{theorem}
\onslide<2>\begin{proof}
    First assume that $T$ is a tree which is connected graph without cycle.
    Because $T$ is connected, there is a path without cycle between two vertices $x$ and $y$.
    Moreover, this path must be unique, for if there were a second such path,
    they would form a cycle.    
    This implies that there is a cycle in $T$.
    
    Now assume that there is a unique path without cycle between any two vertices of a graph $T$.
    Then $T$ is connected, because there is a path between any two of its vertices.
    Furthermore, $T$ can have no cycles.
    To see that this is true, suppose $T$ had a cycle that contained the vertices $x$ and $y$.
    Then there would be two simple paths between $x$ and $y$.
\end{proof}
\end{frame}

\plain{Questions?}

\end{document}
