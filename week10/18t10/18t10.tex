%!TEX program = xelatex
\documentclass[10pt, compress, handout]{beamer}
\usepackage[titleprogressbar]{../../cls/beamerthemem}

\setbeamertemplate{caption}[numbered]
\setbeamertemplate{theorems}[numbered]
\newcounter{example}
\resetcounteronoverlays{example}
\newtheorem{crl}{Corollary}[theorem]
\newtheorem{eg}[example]{Example}
\newtheorem*{solution*}{Solution}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{minted}

\usepackage{cleveref}
\crefname{example}{Example}{Examples}

\usepgfplotslibrary{dateplot}

\usemintedstyle{trac}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\resetcounteronoverlays{algorithm}

\usepackage{version}
%\excludeversion{proof}
%\excludeversion{solution*}

\usepackage{mathtools}
\usepackage{multicol}
\usepackage{qtree}

\usepackage{tikz}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
    \ifmmode%
    \old@comma\discretionary{}{}{}%
    \else%
    \old@comma%
    \fi%
}
\makeatother

\title{CSCI 3190 Tutorial of Week 10}
\subtitle{Mathematical Induction}
\author{LI Haocheng}
\institute{Department of Computer Science and Engineering}

\begin{document}

\maketitle

\begin{frame}
\frametitle{Right Trominoes}
\begin{columns}
    \begin{column}{.3\linewidth}
        \begin{eg}
            Let $n \in \mathbb{N}^+$. Show that every $2^n \times 2^n$ checkerboard with one square removed can be tiled using right trominoes, where these pieces cover three squares at a time.
        \end{eg}
        \begin{figure}
            \includegraphics[width=.4\linewidth]{tromino}
            \caption{Tromino}
        \end{figure}
    \end{column}
    \begin{column}{.8\linewidth}
        \begin{proof}
            \begin{description}
                \item[Base]<2-> $P(1)$ is true, obviously.
                \item[Induction]<3> Split the $2^{k + 1} \times 2^{k + 1}$ checkerboard with one square removed into four checkerboards of size $2^k \times 2^k$. Now temporarily remove the
                square from each of the three full checkerboards at the center of the original. By the inductive hypothesis,
                each of these four checkerboards with a square removed can be tiled by right trominoes. Furthermore, the three squares that were temporarily removed can be covered by one right
                tromino.
            \end{description}
        \end{proof}
    \end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Recursion Algorithm}
\begin{eg}
    Give a recursive algorithm for tiling a $2^n \times 2^n$ checkerboard with one square missing using right trominoes.
\end{eg}
\onslide<2>\begin{solution*}
    If $n = 1$ (basis step), place the one right tromino so that its
    armpit corresponds to the hole in the $2 \times 2$ board. If $n > 1$, then
    divide the board into four boards, each of size $2^{n - 1} \times 2^{n-1}$,
    notice which quarter the hole occurs in, position one right triomino
    at the center of the board with its armpit in the quarter
    where the missing square is, and
    invoke the algorithm recursively four times -- once on each of
    the $2^{n - 1} \times 2^{n - 1}$ boards, each of which has one square missing.
\end{solution*}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Double Tower of Hanoi}
\begin{example}
    A Double Tower of Hanoi contains $2n$ disks of $n$ different sizes, two of each size. As usual, we can move
    only one disk at a time, without putting a larger one over a smaller one. Assume that disks of equal size are
    indistinguishable from each other:\begin{enumerate}[(a)]
        \item Write a pseudo-code to solve the above problem recursively.
        \item Set up a recurrence equation to count the number of steps to move $2n$ disks. 
        \item Solve the recurrence equation and give the complexity of your algorithm.
    \end{enumerate}
\end{example}
\begin{solution*}
    \begin{columns}
        \begin{column}{.5\linewidth}
            \begin{enumerate}[(a)]
                \item See Algorithm \ref{a-3}.        
                \item $H_{2n} = 2H_{2n - 2} + 2$.
                \item \begin{align}
                H_{2n} & = 2(2H_{2n - 4} + 2) + 2\\
                & = 4H_{2n - 4} + 4 + 2\\
                & \cdots\\
                & = 2^{n + 1} - 2.\\
                & = O(2^n).
                \end{align}
            \end{enumerate}
        \end{column}
        \begin{column}{.5\linewidth}
            \begin{algorithm}[H]
                \caption{Double Tower of Hanoi}
                \label{a-3}
                \begin{algorithmic}
                    \Procedure{Hanoi}{$h$, $b$, $e$, $m$}
                    \If{$h$ = 0}
                    \State \Return
                    \ElsIf{$h$ = 2}
                    \State \Call{Move}{$b$, $e$}
                    \State \Call{Move}{$b$, $e$}
                    \Else
                    \State \Call{Hanoi}{$h - 2$, $b$, $m$, $e$}
                    \State \Call{Hanoi}{2, $b$, $e$}
                    \State \Call{Hanoi}{$h - 2$, $m$, $e$, $b$}
                    \EndIf
                    \EndProcedure
                \end{algorithmic}
            \end{algorithm}
        \end{column}
    \end{columns}
\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge Lists}
\begin{eg}
    What is the least number of comparisons needed to merge any two lists in increasing order into one list in increasing order when the number of elements in the two lists are
    
    A) 1, 4? B) 2, 4? C) 3, 4? D) 4, 4?
\end{eg}
\onslide<2>\begin{solution*}
    A.
\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge Sort}
\begin{eg}
    Prove that the merge sort algorithm is correct.
\end{eg}
\onslide<2>\begin{proof}
    If
    $n = 1$, then the algorithm does nothing, which is correct because
    a list with one element is already sorted. Assume that
    the algorithm works correctly for $n = 1$ through $n = k$. If
    $n = k + 1$, then the list is split into two lists, $L_1$ and $L_2$. By the
    inductive hypothesis, \textit{mergesort} correctly sorts each of these
    sublists; furthermore, \textit{merge} correctly merges two sorted lists
    into one because with each comparison the smallest element
    in $L_1 \cup L_2$ not yet put into $L$ is put there.
\end{proof}
\end{frame}

\begin{frame}
\frametitle{Sorting Algorithm}
\begin{theorem} \label{t-11-2-1}
    A sorting algorithm based on binary comparisons requires at least $\lceil \log n! \rceil$ comparisons.
\end{theorem}
\onslide<2>\begin{proof}
    The complexity of a sort based on binary comparisons
    is measured in terms of the number of such comparisons used.
    The largest number of binary comparisons ever needed to sort a list with $n$ elements gives the worst-case performance of the algorithm. The most comparisons used equals the longest path length in the decision tree representing the sorting procedure. In other words, the largest number of comparisons ever needed is equal to the height of the decision tree.
    Because the height of a binary tree with $n!$ leaves is at least $\lceil \log n! \rceil$, at least $\lceil \log n! \rceil$ comparisons are needed.
\end{proof}
\end{frame}

\plain{Questions?}

\end{document}
