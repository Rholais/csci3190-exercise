%!TEX program = xelatex
\documentclass[10pt, compress, handout]{beamer}
\usepackage[titleprogressbar]{../../cls/beamerthemem}

\setbeamertemplate{caption}[numbered]
\setbeamertemplate{theorems}[numbered]
\newcounter{example}
\resetcounteronoverlays{example}
\newtheorem{crl}{Corollary}[theorem]
\newtheorem{eg}[example]{Example}
\newtheorem*{solution*}{Solution}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{minted}

\usepackage{cleveref}
\crefname{example}{Example}{Examples}

\usepgfplotslibrary{dateplot}

\usemintedstyle{trac}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\resetcounteronoverlays{algorithm}

\usepackage{version}
\excludeversion{proof}
\excludeversion{solution*}

\usepackage{mathtools}
\usepackage{multicol}
\usepackage{qtree}

\usepackage{tikz}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
    \ifmmode%
    \old@comma\discretionary{}{}{}%
    \else%
    \old@comma%
    \fi%
}
\makeatother

\title{CSCI 3190 Tutorial of Week 10}
\subtitle{Mathematical Induction}
\author{LI Haocheng}
\institute{Department of Computer Science and Engineering}

\begin{document}

\maketitle

\begin{frame}[fragile]
\frametitle{Merge Lists}
\begin{eg}
    What is the least number of comparisons needed to merge any two lists in increasing order into one list in increasing order when the number of elements in the two lists are
    
    A) 1, 4? B) 2, 4? C) 3, 4? D) 4, 4?
\end{eg}
\onslide<2>\begin{solution*}
    A.
\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge Sort}
\begin{eg}
    Prove that the merge sort algorithm is correct.
\end{eg}
\onslide<2>\begin{proof}
    If
    $n = 1$, then the algorithm does nothing, which is correct because
    a list with one element is already sorted. Assume that
    the algorithm works correctly for $n = 1$ through $n = k$. If
    $n = k + 1$, then the list is split into two lists, $L_1$ and $L_2$. By the
    inductive hypothesis, \textit{mergesort} correctly sorts each of these
    sublists; furthermore, \textit{merge} correctly merges two sorted lists
    into one because with each comparison the smallest element
    in $L_1 \cup L_2$ not yet put into $L$ is put there.
\end{proof}
\end{frame}

\begin{frame}
\frametitle{Sorting Algorithm}
\begin{theorem} \label{t-11-2-1}
    A sorting algorithm based on binary comparisons requires at least $\lceil \log n! \rceil$ comparisons.
\end{theorem}
\onslide<2>\begin{proof}
    The complexity of a sort based on binary comparisons
    is measured in terms of the number of such comparisons used.
    The largest number of binary comparisons ever needed to sort a list with $n$ elements gives the worst-case performance of the algorithm. The most comparisons used equals the longest path length in the decision tree representing the sorting procedure. In other words, the largest number of comparisons ever needed is equal to the height of the decision tree.
    Because the height of a binary tree with $n!$ leaves is at least $\lceil \log n! \rceil$, at least $\lceil \log n! \rceil$ comparisons are needed.
\end{proof}
\end{frame}

\begin{frame}[fragile]
\frametitle{Cycle}
\begin{eg}
    Let $P_1$ and $P_2$ be two paths without cycle between the vertices $u$ and $v$
    in the simple graph $G$ that do not contain the same set of edges (i.e., the two paths are not the same).
    Show that there is a cycle in $G$.
\end{eg}
\onslide<2> \begin{proof}
    Let the paths $P_1$ and $P_2$ be $u = x_0, x_1, \cdots, x_n = v$ and $u = y_0, y_1$,
    $\cdots$, $y_m = v$, respectively. Since the paths do not contain cycles, they must diverge eventually. We can suppose that $x_0 = y_0, x_1 = y_1$, $\cdots$, $x_i = y_i$, but $x_{i + 1} \ne y_{i + 1}$. To form our cycle, we follow the path $y_i, y_{i + 1}, y_{i + 2}$, and so on,
    until it once again first encounters a vertex on $P_1$. Once we are back on $P_1$, we
    follow it along-forwards or backwards, as necessary-to return
    to $x_i$. Since $x_i = y_i$, this certainly forms a cycle.
\end{proof}
\end{frame}

\begin{frame}[fragile]
\frametitle{Tree}
\begin{theorem}
    An undirected graph is a tree if and only if there is a unique path without cycle between any two of its vertices.
\end{theorem}
\onslide<2>\begin{proof}
    First assume that $T$ is a tree which is connected graph without cycle.
    Because $T$ is connected, there is a path without cycle between two vertices $x$ and $y$.
    Moreover, this path must be unique, for if there were a second such path,
    they would form a cycle.    
    This implies that there is a cycle in $T$.
    
    Now assume that there is a unique path without cycle between any two vertices of a graph $T$.
    Then $T$ is connected, because there is a path between any two of its vertices.
    Furthermore, $T$ can have no cycles.
    To see that this is true, suppose $T$ had a cycle that contained the vertices $x$ and $y$.
    Then there would be two simple paths between $x$ and $y$.
\end{proof}
\end{frame}

\plain{Questions?}

\end{document}
