%!TEX program = xelatex
\documentclass[10pt, compress]{beamer}
\usepackage[titleprogressbar]{../../cls/beamerthemem}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{minted}

\usepgfplotslibrary{dateplot}

\usemintedstyle{trac}

\setbeamertemplate{caption}[numbered]
\setbeamertemplate{theorems}[numbered]
\newtheorem{crl}{Corollary}[theorem]
\newtheorem*{solution*}{Solution}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{version}
%\excludeversion{proof}
%\excludeversion{solution*}

\usepackage{mathtools}
\usepackage{multicol}
\usepackage{qtree}

\usepackage{tikz}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
	\ifmmode%
	\old@comma\discretionary{}{}{}%
	\else%
	\old@comma%
	\fi%
}
\makeatother

\title{CSCI 3190 Tutorial of Week 10}
\subtitle{Recursive Algorithms}
\author{LI Haocheng}
\institute{Department of Computer Science and Engineering}

\begin{document}

\maketitle

\begin{frame}
\frametitle{Multiply}
\begin{columns}
	\begin{column}{.5\linewidth}
		\begin{example}
			Give a recursive algorithm for computing $nx$ whenever $n$ is a positive integer and $x$ is an integer, using just addition.
		\end{example}
		\onslide<2->\begin{solution*}
			\begin{algorithm}[H]
				\caption{A Recursive Algorithm for Multiplication}
				\label{a-1}
				\begin{algorithmic}
					\Procedure{mult}{$n \in \mathbb{N}$, $x \in \mathbb{Z}$}
					\If{$n = 0$}
					\State\Return $0$
					\EndIf
					\State\Return $x + $\Call{mult}{$n - 1, x$}
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
		\end{solution*}
	\end{column}
	\begin{column}{.5\linewidth}
		\onslide<1->\begin{example}
			Give a recursive algorithm for finding the sum of the first $n$ positive integers.
		\end{example}
		\onslide<3>\begin{solution*}
			\begin{algorithm}[H]
				\caption{A Recursive Algorithm for Summation}
				\label{a-2}
				\begin{algorithmic}
					\Procedure{sum}{$n \in \mathbb{N}$}
					\If{$n = 0$}
					\State\Return $0$
					\EndIf
					\State\Return $n + $\Call{sum}{$n - 1$}
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
		\end{solution*}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Minimum}
\begin{example}
	Give a recursive algorithm for finding the minimum of a finite set of integers, making use of the fact that the minimum of $n$ integers is the smaller of the last integer in the list and the minimum of the first $n - 1$ integers in the list.
\end{example}
\onslide<2>\begin{solution*}
	\begin{algorithm}[H]
		\caption{A Recursive Algorithm for Minimum}
		\label{a-3}
		\begin{algorithmic}
			\Procedure{smallest}{$a_1, \cdots, a_n \in \mathbb{Z}$}
			\If{$n = 1$}
			\State\Return $a_1$
			\EndIf
			\State\Return $\min(a_n, $ \Call{smallest}{$a_1, \cdots, a_{n - 1}$})
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
\end{solution*}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Fibonacci}
\begin{example}
	Consider the computation of the $n$-th Fibonacci number:\begin{enumerate}
		\item Give the pseudo code of a recursive algorithm to compute the nth Fibonacci number. What is the
		complexity of your algorithm? Explain your answer.
		\item Give the pseudo code of an iterative algorithm to compute the nth Fibonacci number. What is the
		complexity of your algorithm? Explain your answer. 
	\end{enumerate}
\end{example}

%\newpage

\begin{columns}
	\begin{column}{.6\linewidth}
		\begin{algorithm}[H]
			\caption{A Recursive Algorithm for Fibonacci}
			\label{a-4-1}
			\begin{algorithmic}
				\Procedure{Fib}{$n$}
				\If{$n = 0$}
				\State\Return $0$
				\EndIf
				\If{$n = 1$}
				\State\Return $1$
				\EndIf
				\State\Return \Call{Fib}{$n - 1$} + \Call{Fib}{$n - 2$}
				\EndProcedure
			\end{algorithmic}
		\end{algorithm}

		$O(a_n) = 2^n$.
	\end{column}

	\begin{column}{.5\linewidth}
		\begin{algorithm}[H]
			\caption{A Iterative Algorithm for Fibonacci}
			\label{a-4-2}
			\begin{algorithmic}
				\Procedure{IterFib}{$n$}
				\If{$n = 0$}\ \Return $0$
				\EndIf
				\State $x \coloneqq 0, y \coloneqq 1$
				\For{$i \coloneqq 1, 2, \cdots, n - 1$}
				\State $z \coloneqq x + y, x \coloneqq y, y \coloneqq z$
				\EndFor
				\State \Return $y$
				\EndProcedure
			\end{algorithmic}
		\end{algorithm}
		
		The number of additions follows the expression $b_n = n - 1$ so that $O(b_n) = n$.
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Mode}
\begin{example}
	Give a recursive algorithm for finding a mode of a list of integers.
\end{example}
\onslide<2>\begin{solution*}
	\begin{algorithm}[H]
		\caption{A Recursive Algorithm for Minimum}
		\label{a-5}
		\begin{algorithmic}
			\Procedure{mode}{$a_1, \cdots, a_n \in \mathbb{Z}$}
			\If{$n = 1$}
			\Return $a_1$
			\EndIf
			\State $m \eqqcolon $ \Call{mode}{$a_1, \cdots, a_{n - 1}$}
			\If{$m = a_n$}
			\Return $a_n$
			\EndIf
			\State $numM \eqqcolon$ number of $m$ in $a_1, \cdots, a_n$
			\State $numN \eqqcolon$ number of $a_n$ in $a_1, \cdots, a_n$
			\If{$numM \le numN$}
			\Return $a_n$
			\EndIf
			\State\Return $m$
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
\end{solution*}
\end{frame}

\begin{frame}
\frametitle{Right Trominoes}
\begin{columns}
	\begin{column}{.3\linewidth}
		\begin{example}
			Let $n \in \mathbb{N}^+$. Show that every $2^n \times 2^n$ checkerboard with one square removed can be tiled using right trominoes, where these pieces cover three squares at a time.
		\end{example}
		\begin{figure}
			\includegraphics[width=.4\linewidth]{tromino}
			\caption{Tromino}
		\end{figure}
	\end{column}
	\begin{column}{.8\linewidth}
		\begin{proof}
			\begin{description}
				\item[Base]<2-> $P(1)$ is true, obviously.
				\item[Induction]<3> Split the $2^{k + 1} \times 2^{k + 1}$ checkerboard with one square removed into four checkerboards of size $2^k \times 2^k$. Now temporarily remove the
				square from each of the three full checkerboards at the center of the original. By the inductive hypothesis,
				each of these four checkerboards with a square removed can be tiled by right trominoes. Furthermore, the three squares that were temporarily removed can be covered by one right
				tromino.
			\end{description}
		\end{proof}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Recursion Algorithm}
	\begin{example}
		Give a recursive algorithm for tiling a $2^n \times 2^n$ checkerboard with one square missing using right trominoes.
	\end{example}
	\onslide<2>\begin{solution*}
		If $n = 1$ (basis step), place the one right tromino so that its
		armpit corresponds to the hole in the $2 \times 2$ board. If $n > 1$, then
		divide the board into four boards, each of size $2^{n - 1} \times 2^{n-1}$,
		notice which quarter the hole occurs in, position one right triomino
		at the center of the board with its armpit in the quarter
		where the missing square is, and
		invoke the algorithm recursively four times -- once on each of
		the $2^{n - 1} \times 2^{n - 1}$ boards, each of which has one square missing.
	\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge Lists}
\begin{example}
	What is the least number of comparisons needed to merge any two lists in increasing order into one list in increasing order when the number of elements in the two lists are
	
	A) 1, 4? B) 2, 4? C) 3, 4? D) 4, 4?
\end{example}
\onslide<2>\begin{solution*}
	A.
\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge Sort}
\begin{example}
	Prove that the merge sort algorithm is correct.
\end{example}
\begin{proof}
	If
	$n = 1$, then the algorithm does nothing, which is correct because
	a list with one element is already sorted. Assume that
	the algorithm works correctly for $n = 1$ through $n = k$. If
	$n = k + 1$, then the list is split into two lists, $L_1$ and $L_2$. By the
	inductive hypothesis, \textit{mergesort} correctly sorts each of these
	sublists; furthermore, \textit{merge} correctly merges two sorted lists
	into one because with each comparison the smallest element
	in $L_1 \cup L_2$ not yet put into $L$ is put there.
\end{proof}
\end{frame}

\plain{Questions?}

\end{document}
