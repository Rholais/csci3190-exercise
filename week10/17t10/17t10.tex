%!TEX program = xelatex
\documentclass[10pt, compress, handout]{beamer}
\usepackage[titleprogressbar]{../../cls/beamerthemem}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{minted}

\usepgfplotslibrary{dateplot}

\usemintedstyle{trac}

\setbeamertemplate{caption}[numbered]
\setbeamertemplate{theorems}[numbered]
\newtheorem{crl}{Corollary}[theorem]
\newtheorem*{solution*}{Solution}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{version}
%\excludeversion{proof}
%\excludeversion{solution*}

\usepackage{mathtools}
\usepackage{multicol}
\usepackage{qtree}

\usepackage{tikz}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
	\ifmmode%
	\old@comma\discretionary{}{}{}%
	\else%
	\old@comma%
	\fi%
}
\makeatother

\title{CSCI 3190 Tutorial of Week 10}
\subtitle{Recursive Algorithms}
\author{LI Haocheng}
\institute{Department of Computer Science and Engineering}

\begin{document}

\maketitle

\begin{frame}
\frametitle{Right Trominoes}
\begin{columns}
	\begin{column}{.3\linewidth}
		\begin{example}
			Let $n \in \mathbb{N}^+$. Show that every $2^n \times 2^n$ checkerboard with one square removed can be tiled using right trominoes, where these pieces cover three squares at a time.
		\end{example}
		\begin{figure}
			\includegraphics[width=.4\linewidth]{tromino}
			\caption{Tromino}
		\end{figure}
	\end{column}
	\begin{column}{.8\linewidth}
		\begin{proof}
			\begin{description}
				\item[Base]<2-> $P(1)$ is true, obviously.
				\item[Induction]<3> Split the $2^{k + 1} \times 2^{k + 1}$ checkerboard with one square removed into four checkerboards of size $2^k \times 2^k$. Now temporarily remove the
				square from each of the three full checkerboards at the center of the original. By the inductive hypothesis,
				each of these four checkerboards with a square removed can be tiled by right trominoes. Furthermore, the three squares that were temporarily removed can be covered by one right
				tromino.
			\end{description}
		\end{proof}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Recursion Algorithm}
	\begin{example}
		Give a recursive algorithm for tiling a $2^n \times 2^n$ checkerboard with one square missing using right trominoes.
	\end{example}
	\onslide<2>\begin{solution*}
		If $n = 1$ (basis step), place the one right tromino so that its
		armpit corresponds to the hole in the $2 \times 2$ board. If $n > 1$, then
		divide the board into four boards, each of size $2^{n - 1} \times 2^{n-1}$,
		notice which quarter the hole occurs in, position one right triomino
		at the center of the board with its armpit in the quarter
		where the missing square is, and
		invoke the algorithm recursively four times -- once on each of
		the $2^{n - 1} \times 2^{n - 1}$ boards, each of which has one square missing.
	\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge Lists}
\begin{example}
	What is the least number of comparisons needed to merge any two lists in increasing order into one list in increasing order when the number of elements in the two lists are
	
	A) 1, 4? B) 2, 4? C) 3, 4? D) 4, 4?
\end{example}
\onslide<2>\begin{solution*}
	A.
\end{solution*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge Sort}
\begin{example}
	Prove that the merge sort algorithm is correct.
\end{example}
\onslide<2>\begin{proof}
	If
	$n = 1$, then the algorithm does nothing, which is correct because
	a list with one element is already sorted. Assume that
	the algorithm works correctly for $n = 1$ through $n = k$. If
	$n = k + 1$, then the list is split into two lists, $L_1$ and $L_2$. By the
	inductive hypothesis, \textit{mergesort} correctly sorts each of these
	sublists; furthermore, \textit{merge} correctly merges two sorted lists
	into one because with each comparison the smallest element
	in $L_1 \cup L_2$ not yet put into $L$ is put there.
\end{proof}
\end{frame}

\plain{Questions?}

\end{document}
