%!TEX program = xelatex
\documentclass[10pt, compress, handout]{beamer}
\usepackage[titleprogressbar]{../../cls/beamerthemem}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage{minted}

\usepgfplotslibrary{dateplot}

\usemintedstyle{trac}

\setbeamertemplate{caption}[numbered]
\setbeamertemplate{theorems}[numbered]
\newtheorem{crl}{Corollary}[theorem]
\newtheorem*{solution*}{Solution}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{version}
\excludeversion{proof}
\excludeversion{solution*}

\usepackage{mathtools}
\usepackage{multicol}
\usepackage{qtree}

\makeatletter
\def\old@comma{,}
\catcode`\,=13
\def,{%
	\ifmmode%
	\old@comma\discretionary{}{}{}%
	\else%
	\old@comma%
	\fi%
}
\makeatother

\title{CSCI 3190 Tutorial of Week 10}
\subtitle{Traversal}
\author{LI Haocheng}
\institute{Department of Computer Science and Engineering}

\begin{document}

\maketitle

\begin{frame}[fragile]
	\frametitle{Mathematical Induction}
	\onslide<1->\begin{example}
		For positive integer $n$, prove each of the following by mathematical induction:\begin{enumerate}[(a)]
			\item $3 \mid 2^{2n + 1} + 1$
			\item $9 \mid n^3 + (n + 1)^3 + (n + 2)^3$
		\end{enumerate}
	\end{example}
	\onslide<2>\begin{proof}
		\begin{enumerate}[(a)]
			\item \begin{enumerate}[(i)]
				\item Let $n = 0$, $3 \mid 2^1 + 1 = 3$.
				\item Suppose $3 \mid 2^{2n - 1} + 1$, $2^{2n + 1} = 3 * 2^{2n - 1} + 2^{2n - 1} + 1 \equiv 0 \pmod{3}$.
			\end{enumerate}
			\item \begin{enumerate}[(i)]
				\item Let $n = 0$, $9 \mid 1^3 + 2^3$.
				\item Suppose $9 \mid (n - 1)^3 + n^3 + (n + 1)^3$, $n^3 + (n + 1)^3 + (n + 2)^3 = (n - 1)^3 + n^3 + (n + 1)^3 + 3((n - 1)^2 + (n - 1)(n + 2) + (n + 2)^2) = (n - 1)^3 + n^3 + (n + 1)^3 + 9(n^2 + n + 1) \equiv 0 \pmod{9}$.
			\end{enumerate}
		\end{enumerate}
	\end{proof}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Preorder}
	\begin{columns}
		\begin{column}{.6\linewidth}
			\onslide<1->\begin{example}
				Determine the order in which a preorder traversal visits the vertices of the given ordered rooted tree in Figure \ref{f-11-3-e7}.
			\end{example}
			\onslide<2>\begin{solution*}
				$a, b, d, e, f, g, c$.
			\end{solution*}
		\end{column}
		\onslide<1->\begin{column}{.4\linewidth}
			\begin{figure}
				\centering
				$\Tree [.a [.b d [.e f g ]] c ]$
				\caption{A Rooted Tree $T$}
				\label{f-11-3-e7}
			\end{figure}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Inorder}
	\begin{columns}
		\begin{column}{.6\linewidth}
			\onslide<1->\begin{example}
				Determine the order in which a inorder traversal visits the vertices of the given ordered rooted tree in Figure \ref{f-11-3-e7-1}.
			\end{example}
			\onslide<2>\begin{solution*}
				$d, b, f, e, g, a, c$.
			\end{solution*}
		\end{column}
		\onslide<1->\begin{column}{.4\linewidth}
			\begin{figure}
				\centering
				$\Tree [.a [.b d [.e f g ]] c ]$
				\caption{A Rooted Tree $T$}
				\label{f-11-3-e7-1}
			\end{figure}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Postorder}
	\begin{columns}
		\begin{column}{.6\linewidth}
			\onslide<1->\begin{example}
				Determine the order in which a postorder traversal visits the vertices of the given ordered rooted tree in Figure \ref{f-11-3-e7-2}.
			\end{example}
			\onslide<2>\begin{solution*}
				$d, f, g, e, b, c, a$.
			\end{solution*}
		\end{column}
		\onslide<1->\begin{column}{.4\linewidth}
			\begin{figure}
				\centering
				$\Tree [.a [.b d [.e f g ]] c ]$
				\caption{A Rooted Tree $T$}
				\label{f-11-3-e7-2}
			\end{figure}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Expression}
	\begin{columns}
		\begin{column}{.6\linewidth}
			\onslide<1->\begin{example}
				\begin{enumerate}
					\item Represent the expression $((x + 2) \uparrow 3) \cdot (y - (3 + x)) - 5$ using a binary tree.
					\item Write this expression in prefix notation.
					\item Write this expression in postfix notation.
					\item Write this expression in infix notation.
				\end{enumerate}
			\end{example}
			\onslide<2>\begin{solution*}
				\begin{enumerate}
					\item $-\ \cdot\ \uparrow\ +\ x\ 2\ 3\ -\ y\ +\ 3\ x\ 5$
					\item $x\ 2\ +\ 3\ \uparrow\ y\ 3\ x\ +\ -\ \cdot\ 5\ -$
					\item $x\ +\ 2\ \uparrow\ 3\ \cdot\ y\ -\ 3\ +\ x\ -\ 5$
				\end{enumerate}
			\end{solution*}
		\end{column}
		\onslide<2>\begin{column}{.4\linewidth}
			\begin{solution*}
				\begin{figure}
					\centering
					$\Tree [.- [.\(\cdot\) [.\(\uparrow\) [.+ x 2 ] 3 ] [.- y [.+ 3 x ] ] ] 5 ]$
					\caption{A Rooted Tree $T$}
					\label{f-11-3-e16}
				\end{figure}
			\end{solution*}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Construction}
	\begin{columns}
		\begin{column}{.6\linewidth}
			\onslide<1->\begin{example}
				Construct the ordered rooted tree whose preorder traversal is $a, b, f, c, g, h, i, d, e, j, k, l$, where $a$ has four children, $c$ has three children, $j$ has two children, $b$ and $e$ have one child each, and all other vertices are leaves.
			\end{example}
		\end{column}
		\onslide<2>\begin{column}{.4\linewidth}
			\begin{solution*}
				\begin{figure}
					\centering
					$\Tree [.a [.b f ] [.c g h i ] d [.e [.j k l ] ] ]$
					\caption{A Rooted Tree $T$}
					\label{f-11-3-e25}
				\end{figure}
			\end{solution*}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Complexity}
	\onslide<1->\begin{example}
		Show the following:\begin{enumerate}[(a)]
			\item $3n^2 + 5n + 10 = O(n^2)$
		\end{enumerate}
	\end{example}
	\onslide<2>\begin{proof}
		\begin{enumerate}[(a)]
			\item \begin{description}
				\item[Method 1] $\exists c = 4, \exists N = 6$, such that $\forall n > N, 3n^2 + 5n + 10 < 4n^2$.
				\item[Method 2] Since $3 + \frac{5}{n} + \frac{10}{n^2} = O(1)$ and $n^2 = O(n^2)$, $3n^2 + 5n + 10 = O(n^2)$.
			\end{description}
		\end{enumerate}
	\end{proof}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Complexity}
	\onslide<1->\begin{example}
		Show the following:\begin{enumerate}[(b)]
			\item $100 \log_2 n = O(n)$
		\end{enumerate}
	\end{example}
	\onslide<2>\begin{proof}
		\begin{enumerate}[(b)]
			\item \begin{description}
				\item[Method 1] Since $100 = O(1)$ and $\log_2 n = O(n)$, $100\log_2 n = O(n)$.
				\item[Method 2] \begin{align}
				& \lim\limits_{n \rightarrow \infty} \frac{100\log_2 n}{n}\\
				= & \frac{100}{\ln 2} \lim\limits_{n \rightarrow \infty} \frac{1}{n}\\
				= & 0
				\end{align}
			\end{description}
		\end{enumerate}
	\end{proof}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Complexity}
	\onslide<1->\begin{example}
		Show the following:\begin{enumerate}[(a)]
			\setcounter{enumi}{2}
			\item $n! = O(n^n)$
			\item $2^n = O(n!)$
		\end{enumerate}
	\end{example}
	\onslide<2>\begin{proof}
		\begin{enumerate}[(a)]
			\setcounter{enumi}{2}
			\item $n! = \Pi_{i = 1}^n i \le \Pi_{i = 1}^n n = n^n$.
			\item $\exists c = 2, \exists N = 1$, such that $\forall n > N, 2^n = \Pi_{i = 1}^n 2 = 2 \Pi_{i = 2}^n 2 \le 2 \Pi_{i = 2}^n i = 2(n!)$.
		\end{enumerate}
	\end{proof}
\end{frame}

\begin{frame}[allowframebreaks]
	\frametitle{Double Tower of Hanoi}
	\begin{example}
		A Double Tower of Hanoi contains $2n$ disks of $n$ different sizes, two of each size. As usual, we can move
		only one disk at a time, without putting a larger one over a smaller one. Assume that disks of equal size are
		indistinguishable from each other:\begin{enumerate}[(a)]
			\item Write a pseudo-code to solve the above problem recursively.
			\item Set up a recurrence equation to count the number of steps to move $2n$ disks. 
			\item Solve the recurrence equation and give the complexity of your algorithm.
		\end{enumerate}
	\end{example}
	\begin{solution*}
		\begin{columns}
			\begin{column}{.5\linewidth}
				\begin{enumerate}[(a)]
					\item See Algorithm \ref{a-3}.		
					\item $H_{2n} = 2H_{2n - 2} + 2$.
					\item \begin{align}
					H_{2n} & = 2(H_{2n - 4} + 2) + 2\\
					& = 2H_{2n - 4} + 4 + 2\\
					& \cdots\\
					& = 2^{n + 1} - 2.\\
					O(H_{2n}) & = 2^n.
					\end{align}
				\end{enumerate}
			\end{column}
			\begin{column}{.5\linewidth}
				\begin{algorithm}[H]
					\caption{Double Tower of Hanoi}
					\label{a-3}
					\begin{algorithmic}
						\Procedure{Hanoi}{$h$, $b$, $e$, $m$}
						\If{$h$ = 0}
						\State \Return
						\ElsIf{$h$ = 2}
						\State \Call{Move}{$b$, $e$}
						\State \Call{Move}{$b$, $e$}
						\Else
						\State \Call{Hanoi}{$h - 2$, $b$, $m$, $e$}
						\State \Call{Hanoi}{2, $b$, $e$}
						\State \Call{Hanoi}{$h - 2$, $m$, $e$, $b$}
						\EndIf
						\EndProcedure
					\end{algorithmic}
				\end{algorithm}
			\end{column}
		\end{columns}
	\end{solution*}
\end{frame}

\begin{frame}[allowframebreaks]
	\frametitle{Fibonacci}
	\begin{example}
		Consider the computation of the $n$-th Fibonacci number:\begin{enumerate}[(a)]
			\item Give the pseudo code of a recursive algorithm to compute the nth Fibonacci number. What is the
			complexity of your algorithm? Explain your answer.
			\item Give the pseudo code of an iterative algorithm to compute the nth Fibonacci number. What is the
			complexity of your algorithm? Explain your answer. 
		\end{enumerate}
	\end{example}

	\newpage

	\begin{solution*}
		\begin{enumerate}[(a)]
			\item See Algorithm \ref{a-4-1}.
			\begin{algorithm}[H]
				\caption{A Recursive Algorithm for Fibonacci}
				\label{a-4-1}
				\begin{algorithmic}
					\Procedure{Fibonacci}{$n$}
					\If{$n = 0$} \Return $0$
					\ElsIf{$n = 1$} \Return $1$
					\Else\ \Return \Call{Fibonacci}{$n - 1$} + \Call{Fibonacci}{$n - 2$}
					\EndIf
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
			
			$O(a_n) = 2^n$.
			
			\item See Algorithm \ref{a-4-2}.
			\begin{algorithm}[H]
				\caption{A Iterative Algorithm for Fibonacci}
				\label{a-4-2}
				\begin{algorithmic}
					\Procedure{IterativeFibonacci}{$n$}
					\If{$n = 0$} \Return $0$
					\Else
					\State $x \coloneqq 0, y \coloneqq 1$
					\For{$i \coloneqq 1, 2, \cdots, n - 1$} $z \coloneqq x + y, x \coloneqq y, y \coloneqq z$
					\EndFor
					\State \Return $y$
					\EndIf
					\EndProcedure
				\end{algorithmic}
			\end{algorithm}
			
			The number of additions follows the expression $b_n = n - 1$ so that $O(b_n) = n$.
		\end{enumerate}
	\end{solution*}
\end{frame}

\begin{frame}[allowframebreaks]
	\frametitle{Longest Common Subsequence}
	\begin{example}
		Consider the longest common subsequence problem between sequence $A[1\cdots m]$ and sequence $B[1\cdots n]$. Give a
		recursive algorithm to print out ALL the longest common subsequences assuming that you already build the
		table $T[1\cdots m, 1\cdots n]$ where the entry $T[j, k]$ represents the length of the longest common subsequence between $A[1\cdots j]$ and $B[1\cdots k]$.
	\end{example}
	\begin{solution*}
		See Algorithm \ref{a-5}.
		\begin{algorithm}[H]
			\caption{Print Out ALL the LCSes}
			\label{a-5}
			\begin{algorithmic}
				\Procedure{All}{$T$, $A$, $B$, $j$, $k$}
				\If{$j \cdot k = 0$} \Return $\{``"\}$
				\ElsIf{$A[j] = B[k]$} \Return $\{C + A[j] \colon Z \in \Call{All}{T, A, B, j - 1, k - 1}\}$
				\Else
				\State $R \coloneqq \{\}$
				\If{$T[j, k - 1] \ge T[j - 1, k]$} $R \coloneqq R \cup \Call{All}{T, A, B, j, k - 1}$
				\EndIf
				\If{$T[j - 1, k] \ge T[j, k - 1]$} $R \coloneqq R \cup \Call{All}{T, A, B, j - 1, k}$
				\EndIf
				\State \Return $R$
				\EndIf
				\EndProcedure
			\end{algorithmic}
		\end{algorithm}
	\end{solution*}
\end{frame}

\plain{Questions?}

\end{document}
